# 编译原理第4次作业

姓名:胡瑞康

学号:22336087

# Exercise 4.1

Given the following grammar
$$
S\to(L)|a
$$
$$
L\to L,S|S
$$
- Eliminate left recursions in the grammar.
- Draw the transition diagrams for the grammar
- Write a recursive descent predictive parser.
- Indicate the procedure call sequence for an input sentence $(a,(a,a))$.

## 消除左递归


原始文法为
$$
\begin{aligned}
S &\to (L) \;|\; a\\[1mm]
L &\to L,\,S \;|\; S
\end{aligned}
$$
其中产生式$L\to L,\,S$含有直接左递归。

利用消除左递归的标准方法，对于形如
$$
A\to A\alpha \;|\; \beta
$$
可改写为
$$
\begin{aligned}
A &\to \beta A'\\[1mm]
A' &\to \alpha A' \;|\; \epsilon
\end{aligned}
$$
因此令 $A = L$、$\beta = S$ 且 $\alpha = ,\,S$，得到消除左递归后的文法：

$$
\begin{aligned}
S &\to (L) \;|\; a\\[1mm]
L &\to S\,L'\\[1mm]
L' &\to ,\,S\,L' \;|\; \epsilon
\end{aligned}
$$

## 绘制状态图

$ S \to (L) \;|\; a $

![](./1.svg)

$ L \to S L' $

![](./2.svg)

$ L' \to , S L' \;|\; \epsilon\ $

![](./3.svg)


## Parser伪代码

```c
void S() {
    // S → ( L ) | a
    if (lookahead == '(') {
        match('(');
        L();
        match(')');
    } else if (lookahead == 'a') {
        match('a');
    } else {
        error();
    }
}
void L() {
    // L → S L'
    S();
    LPrime();
}
void LPrime() {
    // L' → , S L' | ε
    if (lookahead == ',') {
        match(',');
        S();
        LPrime();
    }
    // 如果不是逗号，直接 ε 返回
}
void match(char tok) {
    if (lookahead == tok) {
        lookahead = scanner.getNextToken();
    } else {
        error();
    }
}
```

## 调用序列

输入：$(a,(a,a))$，
token序列为：`(`, `a`, `,`, `(`, `a`, `,`, `a`, `)`, `)`。

模拟过程：
1. **S()**
   - 前看 = '('，执行：`match('(')` → $L$ → `match(')')`
   - 下一token：'a'

2. **L()**
   - 调用 `S()` → `LPrime()`

3. **S()**（嵌套）
   - 前看 = 'a'，执行：`match('a')`
   - 下一token：','

4. **LPrime()**
   - 前看 = ','，执行：`match(',')` → `S()` → `LPrime()`
   - 下一token：'('

5. **S()**（嵌套）
   - 前看 = '('，执行：`match('(')` → $L$ → `match(')')`
   - 下一token：'a'

6. **L()**（嵌套）
   - 调用 `S()` → `LPrime()`

7. **S()**（嵌套）
   - 前看 = 'a'，执行：`match('a')`
   - 下一token：','

8. **LPrime()**（嵌套）
   - 前看 = ','，执行：`match(',')` → `S()` → `LPrime()`
   - 下一token：'a'

9. **S()**（嵌套）
   - 前看 = 'a'，执行：`match('a')`
   - 下一token：')'

10. **LPrime()**（嵌套）
    - 前看 = ')'，不是 ','，执行 $\epsilon$（无动作，返回）

11. **回到 S()**，完成 `match(')')`
    - 下一token：')'

12. **回到 LPrime()**
    - 前看 = ')'，不是 ','，执行 $\epsilon$（返回）

13. **回到 S()**，完成 `match(')')`
    - 输入结束

调用序列：
- `S()`
  - `match('(')`
  - `L()`
    - `S()`
      - `match('a')`
    - `LPrime()`
      - `match(',')`
      - `S()`
        - `match('(')`
        - `L()`
          - `S()`
            - `match('a')`
          - `LPrime()`
            - `match(',')`
            - `S()`
              - `match('a')`
            - `LPrime()` (ε)
        - `match(')')`
      - `LPrime()` (ε)
  - `match(')')`








# Exercise 4.2
Consider the context-free grammar
$$
S\to aSbS|bSaS|\varepsilon
$$
Can you construct a predictive parser for the grammar? and why?

1. **求 FIRST 集合**
   - 对于产生式 $S \to aSbS$，显然 FIRST 为 $\{a\}$；
   - 对于产生式 $S \to bSaS$，FIRST 为 $\{b\}$；
   - 对于产生式 $S \to \varepsilon$，FIRST 为 $\{\varepsilon\}$。

2. **求 FOLLOW 集合**
   - 由于 $S$ 为开始符号，$\$$ 总在 FOLLOW($S$) 中；
   - 在 $S \to aSbS$ 中，第一个 $S$ 后跟终结符 $b$；
   - 在 $S \to bSaS$ 中，第一个 $S$ 后跟终结符 $a$；
   - 故 FOLLOW($S$) 至少包含 $\{a, b, \$\}$。

3. **构造 LL(1) 分析表**
   - 对于产生式 $S \to aSbS$，在 M[$S$, $a$] 中填入该产生式；
   - 对于产生式 $S \to bSaS$，在 M[$S$, $b$] 中填入该产生式；
   - 对于产生式 $S \to \varepsilon$，由于 $\varepsilon \in$ FIRST，此时应把产生式填入所有属于 FOLLOW($S$) 的终结符对应的表项，即 M[$S$, $a$]、M[$S$, $b$] 和 M[$S$, $\$$]。

4. **冲突分析**
   - 显然，当输入符号为 $a$ 时，M[$S$, $a$] 同时有 $S \to aSbS$ 和 $S \to \varepsilon$ 两个产生式，存在冲突；
   - 类似地，输入符号为 $b$ 时也会出现冲突。

因此，该文法不满足 LL(1) 条件，无法构造一个没有二义性的预测分析器。

**最终回答：**
不能构造预测分析器。原因在于该文法不是 LL(1) 的，在构造预测分析表时会因 FIRST 与 FOLLOW 集合的交叉导致冲突，从而无法消除二义性。


# Exercise 4.3


Compute the FIRST and FOLLOW for the start symbol of the following grammar
$$
S\to S S +|S S *|a
$$

首先，我们写出文法产生式：
$$
\begin{aligned}
S &\to S\,S\,+ \\
S &\to S\,S\,* \\
S &\to a
\end{aligned}
$$

求 FIRST 集合

对于非终结符 $S$：
- 考察产生式 $S \to a$：显然 $\text{FIRST}(a)=\{a\}$。
- 对于产生式 $S \to S\,S\,+$ 和 $S \to S\,S\,*$，由于这两条产生式都是左递归，最终都必须从 $S$ 推导出终结符。由于唯一给出终结符的产生式是 $S \to a$，因此无论如何推导，导出的串一定以 $a$ 开头。

所以有：
$$
\text{FIRST}(S)=\{a\}.
$$

求 FOLLOW 集合

由于 $S$ 是文法的开始符号，所以 $\$$ 必在 $\text{FOLLOW}(S)$ 中，即：
$$
\$ \in \text{FOLLOW}(S).
$$

现在，分析各产生式中 $S$ 出现后的符号：

在产生式 $S \to S\,S\,+$ 中：
- 第一个 $S$ 后面紧跟非终结符 $S$，而 $\text{FIRST}(S)=\{a\}$，故：
  $$
  a \in \text{FOLLOW}(S).
  $$
- 第二个 $S$ 后面紧跟终结符 $+$，故：
  $$
  + \in \text{FOLLOW}(S).
  $$

在产生式 $S \to S\,S\,*$ 中：
- 第一个 $S$ 后面紧跟 $S$，同样有：
  $$
  a \in \text{FOLLOW}(S).
  $$
- 第二个 $S$ 后面紧跟终结符 $*$，故：
  $$
  * \in \text{FOLLOW}(S).
  $$

综上，$\text{FOLLOW}(S)$ 为：
$$
\text{FOLLOW}(S)=\{a,\,+,\,*,\,\$\}.
$$